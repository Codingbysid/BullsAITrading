"""
Data sources module for market data ingestion.

This module handles data collection from multiple sources including:
- Finazon API (primary)
- Alpha Vantage (fundamental data)
- Twelve Data (backup)
- YFinance (fallback)
"""

import asyncio
import aiohttp
import pandas as pd
import yfinance as yf
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timedelta
import logging
from dataclasses import dataclass

from ..config.settings import get_settings

logger = logging.getLogger(__name__)


@dataclass
class MarketData:
    """Market data structure."""
    symbol: str
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: int
    source: str


class DataSource:
    """Base class for data sources."""
    
    def __init__(self, api_key: str, rate_limit: int = 60):
        self.api_key = api_key
        self.rate_limit = rate_limit
        self.last_request_time = 0
        
    async def _rate_limit_check(self):
        """Implement rate limiting."""
        current_time = datetime.now().timestamp()
        time_since_last = current_time - self.last_request_time
        min_interval = 60 / self.rate_limit
        
        if time_since_last < min_interval:
            await asyncio.sleep(min_interval - time_since_last)
        
        self.last_request_time = datetime.now().timestamp()
    
    async def get_historical_data(
        self, 
        symbol: str, 
        start_date: datetime, 
        end_date: datetime
    ) -> pd.DataFrame:
        """Get historical market data."""
        raise NotImplementedError


class FinazonDataSource(DataSource):
    """Finazon API data source."""
    
    def __init__(self, api_key: str):
        super().__init__(api_key, rate_limit=5)  # 5 API RPM as per documentation
        self.base_url = "https://api.finazon.io/latest"
        self.headers = {"Authorization": f"apikey {api_key}"}
    
    async def get_historical_data(
        self, 
        symbol: str, 
        start_date: datetime, 
        end_date: datetime
    ) -> pd.DataFrame:
        """Get historical data from Finazon."""
        await self._rate_limit_check()
        
        url = f"{self.base_url}/finazon/us_stocks_essential/time_series"
        params = {
            "ticker": symbol,
            "interval": "1d",
            "start_at": int(start_date.timestamp()),
            "end_at": int(end_date.timestamp()),
            "page_size": 1000
        }
        
        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(url, headers=self.headers, params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        return self._parse_finazon_data(data, symbol)
                    else:
                        logger.error(f"Finazon API error: {response.status}")
                        return pd.DataFrame()
            except Exception as e:
                logger.error(f"Error fetching data from Finazon: {e}")
                return pd.DataFrame()
    
    def _parse_finazon_data(self, data: Dict, symbol: str) -> pd.DataFrame:
        """Parse Finazon API response."""
        if "data" not in data:
            return pd.DataFrame()
        
        records = []
        for item in data["data"]:
            records.append({
                "symbol": symbol,
                "timestamp": pd.to_datetime(item["t"], unit='s'),
                "open": float(item["o"]),
                "high": float(item["h"]),
                "low": float(item["l"]),
                "close": float(item["c"]),
                "volume": int(item["v"]),
                "source": "finazon"
            })
        
        df = pd.DataFrame(records)
        df.set_index("timestamp", inplace=True)
        return df


class AlphaVantageDataSource(DataSource):
    """Alpha Vantage API data source."""
    
    def __init__(self, api_key: str):
        super().__init__(api_key, rate_limit=5)
        self.base_url = "https://www.alphavantage.co/query"
    
    async def get_historical_data(
        self, 
        symbol: str, 
        start_date: datetime, 
        end_date: datetime
    ) -> pd.DataFrame:
        """Get historical data from Alpha Vantage."""
        await self._rate_limit_check()
        
        params = {
            "function": "TIME_SERIES_DAILY",
            "symbol": symbol,
            "apikey": self.api_key,
            "outputsize": "full"
        }
        
        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(self.base_url, params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        return self._parse_alpha_vantage_data(data, symbol)
                    else:
                        logger.error(f"Alpha Vantage API error: {response.status}")
                        return pd.DataFrame()
            except Exception as e:
                logger.error(f"Error fetching data from Alpha Vantage: {e}")
                return pd.DataFrame()
    
    def _parse_alpha_vantage_data(self, data: Dict, symbol: str) -> pd.DataFrame:
        """Parse Alpha Vantage API response."""
        if "Time Series (Daily)" not in data:
            return pd.DataFrame()
        
        records = []
        for date_str, values in data["Time Series (Daily)"].items():
            records.append({
                "symbol": symbol,
                "timestamp": pd.to_datetime(date_str),
                "open": float(values["1. open"]),
                "high": float(values["2. high"]),
                "low": float(values["3. low"]),
                "close": float(values["4. close"]),
                "volume": int(values["5. volume"]),
                "source": "alpha_vantage"
            })
        
        df = pd.DataFrame(records)
        df.set_index("timestamp", inplace=True)
        return df


class YFinanceDataSource(DataSource):
    """YFinance fallback data source."""
    
    def __init__(self):
        super().__init__("", rate_limit=1000)  # No API key needed
    
    async def get_historical_data(
        self, 
        symbol: str, 
        start_date: datetime, 
        end_date: datetime
    ) -> pd.DataFrame:
        """Get historical data from YFinance."""
        try:
            ticker = yf.Ticker(symbol)
            data = ticker.history(
                start=start_date,
                end=end_date,
                interval="1d"
            )
            
            if data.empty:
                return pd.DataFrame()
            
            # Standardize column names
            data = data.rename(columns={
                "Open": "open",
                "High": "high", 
                "Low": "low",
                "Close": "close",
                "Volume": "volume"
            })
            
            data["symbol"] = symbol
            data["source"] = "yfinance"
            data = data.reset_index()
            data = data.rename(columns={"Date": "timestamp"})
            data.set_index("timestamp", inplace=True)
            
            return data
            
        except Exception as e:
            logger.error(f"Error fetching data from YFinance: {e}")
            return pd.DataFrame()


class DataManager:
    """Manages multiple data sources with fallback logic."""
    
    def __init__(self):
        self.settings = get_settings()
        self.sources = {
            "finazon": FinazonDataSource(self.settings.finazon_api_key),
            "alpha_vantage": AlphaVantageDataSource(self.settings.alpha_vantage_api_key),
            "yfinance": YFinanceDataSource()
        }
    
    async def get_market_data(
        self, 
        symbol: str, 
        start_date: datetime, 
        end_date: datetime,
        preferred_source: str = "finazon"
    ) -> pd.DataFrame:
        """
        Get market data with fallback logic.
        
        Args:
            symbol: Stock symbol
            start_date: Start date for data
            end_date: End date for data
            preferred_source: Preferred data source
            
        Returns:
            DataFrame with market data
        """
        # Try preferred source first
        if preferred_source in self.sources:
            data = await self.sources[preferred_source].get_historical_data(
                symbol, start_date, end_date
            )
            if not data.empty:
                return data
        
        # Try fallback sources
        for source_name, source in self.sources.items():
            if source_name != preferred_source:
                data = await source.get_historical_data(symbol, start_date, end_date)
                if not data.empty:
                    logger.info(f"Using fallback source: {source_name}")
                    return data
        
        logger.error(f"No data available for {symbol}")
        return pd.DataFrame()
    
    async def get_multiple_symbols(
        self, 
        symbols: List[str], 
        start_date: datetime, 
        end_date: datetime
    ) -> Dict[str, pd.DataFrame]:
        """Get data for multiple symbols."""
        tasks = []
        for symbol in symbols:
            task = self.get_market_data(symbol, start_date, end_date)
            tasks.append((symbol, task))
        
        results = {}
        for symbol, task in tasks:
            try:
                data = await task
                results[symbol] = data
            except Exception as e:
                logger.error(f"Error fetching data for {symbol}: {e}")
                results[symbol] = pd.DataFrame()
        
        return results


# Global data manager instance
data_manager = DataManager()
